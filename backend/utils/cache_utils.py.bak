import threading
from datetime import datetime, timedelta

# Cache global para evolução do portfólio
_evolution_cache = {}
evolution_cache_lock = threading.Lock()

# Cache para cotação do dólar
dollar_cache = {'rate': 5.8187, 'timestamp': datetime(2000, 1, 1)}
dollar_cache_lock = threading.Lock()

# Cache para controle de rate limit
rate_limit_pause = {'until': None, 'hours': 1}
rate_limit_lock = threading.Lock()

# Lock para cache de portfólio
portfolio_cache_lock = threading.Lock()

def get_from_evolution_cache(key):
    """
    Obtém um valor do cache de evolução de portfólio.
    
    O tempo de vida do cache varia conforme o estado do mercado:
    - Mercado aberto: 30 minutos (1800 segundos)
    - Mercado fechado: até o próximo horário de abertura do mercado
    
    Args:
        key (str): Chave para busca no cache
        
    Returns:
        dict: Dados do cache ou None se não encontrado ou expirado
    """
    from utils.market_utils import is_market_open, get_next_market_open
    
    with evolution_cache_lock:
        if key in _evolution_cache:
            cached = _evolution_cache[key]
            now = datetime.now()
            
            # Definir tempo de vida do cache baseado no estado do mercado
            if is_market_open():
                # Mercado aberto: cache válido por 30 minutos (1800 segundos)
                cache_ttl = 1800  # 30 minutos em segundos
                seconds_elapsed = (now - cached['timestamp']).total_seconds()
                is_valid = seconds_elapsed < cache_ttl
                
                if is_valid:
                    print(f"[CACHE HIT] Usando dados em cache para chave: {key} (mercado aberto - atualizado há {int(seconds_elapsed/60)} minutos)")
                    return cached['data']
                else:
                    print(f"[CACHE EXPIRED] Cache expirado para chave: {key} (mercado aberto - passou dos 30 minutos)")
            else:
                # Mercado fechado: cache válido até a próxima abertura do mercado
                next_open = get_next_market_open()
                is_valid = cached['timestamp'] > get_next_market_open() - timedelta(days=1)
                
                if is_valid:
                    print(f"[CACHE HIT] Usando dados em cache para chave: {key} (mercado fechado)")
                    return cached['data']
                else:
                    print(f"[CACHE EXPIRED] Cache expirado para chave: {key} (mercado fechado - dados anteriores à última abertura)")
    return None

def set_evolution_cache(key, data):
    """
    Armazena um valor no cache de evolução de portfólio.
    
    Args:
        key (str): Chave para o armazenamento
        data (dict): Dados a serem armazenados
    """
    from utils.market_utils import is_market_open, get_next_market_open
    
    now = datetime.now()
    market_state = "aberto" if is_market_open() else "fechado"
    
    with evolution_cache_lock:
        _evolution_cache[key] = {
            'timestamp': now,
            'market_state': market_state,
            'data': data
        }
        
        # Detalhar quando o cache expira
        if is_market_open():
            expiry_time = now + timedelta(minutes=30)
            print(f"[CACHE SET] Dados armazenados para chave: {key} (mercado {market_state}) - expira às {expiry_time.strftime('%H:%M:%S')}")
        else:            next_open = get_next_market_open()
            print(f"[CACHE SET] Dados armazenados para chave: {key} (mercado {market_state}) - válido até próxima abertura do mercado em {next_open.strftime('%d/%m/%Y %H:%M')}")

def clear_evolution_cache_for_user(user_id):
    """
    Limpa o cache de evolução para um usuário específico.
    
    Args:
        user_id (str): ID do usuário
    """
    with evolution_cache_lock:
        keys_to_delete = [k for k in _evolution_cache if k.startswith(f"{user_id}:")]
        for k in keys_to_delete:
            del _evolution_cache[k]
            
def handle_rate_limit(hours=None):
    """
    Configura uma pausa por rate limit.
    
    Args:
        hours (int, optional): Número de horas para pausa. Se None, usa o valor atual incrementado.
    """
    with rate_limit_lock:
        now = datetime.now()
        if hours is not None:
            rate_limit_pause['hours'] = hours
        rate_limit_pause['until'] = now + timedelta(hours=rate_limit_pause['hours'])
        print(f"[RATE LIMIT] yfinance bloqueado. Pausando atualizações por {rate_limit_pause['hours']}h até {rate_limit_pause['until']}")
        # Incrementa o tempo de espera exponencialmente para a próxima pausa
        rate_limit_pause['hours'] *= 2

def is_rate_limited():
    """
    Verifica se o sistema está em pausa por rate limit.
    
    Returns:
        bool: True se estiver em pausa, False caso contrário
    """
    with rate_limit_lock:
        return rate_limit_pause['until'] is not None and datetime.now() < rate_limit_pause['until']

def reset_rate_limit():
    """
    Reseta a pausa por rate limit.
    """
    with rate_limit_lock:
        rate_limit_pause['until'] = None
        rate_limit_pause['hours'] = 1